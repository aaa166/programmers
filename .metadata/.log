!SESSION 2024-10-07 19:31:50.679 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-10-07 19:31:55.817
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-07 19:31:55.817
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-07 19:31:55.817
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-07 19:31:58.441
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.core 4 0 2024-10-07 19:37:38.531
!MESSAGE An exception occurred during push on URI https://github.com/aaa166/programmers.git: https://github.com/aaa166/programmers.git: not authorized
!STACK 0
org.eclipse.jgit.errors.TransportException: https://github.com/aaa166/programmers.git: not authorized
	at org.eclipse.jgit.transport.TransportHttp.connect(TransportHttp.java:685)
	at org.eclipse.jgit.transport.TransportHttp.connect(TransportHttp.java:627)
	at org.eclipse.jgit.transport.TransportHttp.openPush(TransportHttp.java:541)
	at org.eclipse.jgit.transport.PushProcess.execute(PushProcess.java:138)
	at org.eclipse.jgit.transport.Transport.push(Transport.java:1473)
	at org.eclipse.egit.core.op.PushOperation.run(PushOperation.java:254)
	at org.eclipse.egit.ui.internal.push.PushJob.performJob(PushJob.java:86)
	at org.eclipse.egit.ui.internal.jobs.RepositoryJob.run(RepositoryJob.java:59)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.egit.ui 4 0 2024-10-07 19:37:38.533
!MESSAGE Can't connect to any repository: https://github.com/aaa166/programmers.git (https://github.com/aaa166/programmers.git: not authorized)
!SESSION 2024-10-08 13:53:28.368 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-10-08 13:54:03.049
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-08 13:54:03.049
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-08 13:54:03.049
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-08 13:54:07.152
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.lsp4e 2 0 2024-10-08 14:13:40.205
!MESSAGE Could not detect hyperlinks due to timeout after 500 miliseconds
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.operations.declaration.OpenDeclarationHyperlinkDetector.detectHyperlinks(OpenDeclarationHyperlinkDetector.java:94)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2024-10-10 14:11:11.721 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-10-10 14:13:48.475
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-10 14:13:48.475
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-10 14:13:48.475
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-10 14:13:52.535
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-10-11 13:15:19.056 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2024-10-11 13:15:35.137
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2024-10-11 13:16:02.829
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-11 13:16:02.829
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-11 13:16:02.829
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-11 13:16:07.018
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2024-10-11 13:51:01.742
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        int time = 0;
        for (int i = time; i < 1000000; i++) {
			i/ti
		}
        
        return answer;
    }
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-10-11 13:51:01.744
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-10-11 13:51:01.744
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-10-11 13:51:01.853
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        int time = 0;
        for (int i = time; i < 1000000; i++) {
			i/ti
		}
        
        return answer;
    }
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-10-11 13:51:01.854
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-10-11 13:51:01.854
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-10-11 13:51:02.755
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        int time = 0;
        for (int i = time; i < 1000000; i++) {
			i/time
		}
        
        return answer;
    }
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-10-11 13:51:02.756
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-10-11 13:51:02.756
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-10-11 13:51:02.855
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        int time = 0;
        for (int i = time; i < 1000000; i++) {
			i/times
		}
        
        return answer;
    }
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-10-11 13:51:02.858
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-10-11 13:51:02.866
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-10-11 13:51:02.878
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        int time = 0;
        for (int i = time; i < 1000000; i++) {
			i/times
		}
        
        return answer;
    }
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-10-11 13:51:02.879
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-10-11 13:51:02.880
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-10-11 13:51:05.175
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        int time = 0;
        for (int i = time; i < 1000000; i++) {
			i/times
		}
        
        return answer;
    }
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-10-11 13:51:05.176
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-10-11 13:51:05.176
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-10-15 16:38:44.778 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-10-15 16:48:11.748
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-15 16:48:11.748
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-15 16:48:11.748
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-15 16:48:16.458
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-10-17 18:00:10.586 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-10-17 18:01:38.249
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-17 18:01:38.249
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-17 18:01:38.249
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-17 18:01:44.422
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-10-18 17:52:04.613 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-10-18 17:52:46.258
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-18 17:52:46.258
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-18 17:52:46.258
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-18 17:52:52.681
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2024-10-18 17:57:09.608
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.Arrays;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        w*h
        
        
        
        return answer;
    }
    
    
    
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-10-18 17:57:09.611
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-10-18 17:57:09.612
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-10-18 17:57:09.701
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.Arrays;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        w*h
        
        
        
        return answer;
    }
    
    
    
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-10-18 17:57:09.703
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-10-18 17:57:09.703
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-10-21 14:19:35.206 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-10-21 14:48:34.816
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-21 14:48:34.816
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-21 14:48:34.816
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-21 14:48:39.272
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2024-10-21 17:07:54.905
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.Arrays;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    private long gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i < d; i++) {
			i*i
		}
        
        
        return answer;
    }    
    
    
    
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-10-21 17:07:54.908
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-10-21 17:07:54.908
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-10-21 17:07:54.920
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.Arrays;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    private long gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i < d; i++) {
			i*i
		}
        
        
        return answer;
    }    
    
    
    
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-10-21 17:07:54.922
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-10-21 17:07:54.923
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-10-22 14:39:28.184 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-10-22 14:40:12.236
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-22 14:40:12.236
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-22 14:40:12.236
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-22 14:40:18.138
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-10-23 20:16:21.200 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2024-10-23 20:16:30.002
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2024-10-23 20:17:04.573
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-23 20:17:04.573
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-23 20:17:04.573
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-23 20:17:11.539
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-10-25 15:46:33.894 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-10-25 15:47:22.670
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-25 15:47:22.670
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-25 15:47:22.670
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-25 15:47:27.428
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-10-28 14:10:44.013 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2024-10-28 14:10:47.674
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2024-10-28 14:11:08.585
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-28 14:11:08.585
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-28 14:11:08.585
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-28 14:11:14.014
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-10-29 14:47:07.269 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-10-29 15:35:46.584
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-29 15:35:46.584
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-29 15:35:46.584
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-29 15:35:51.147
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2024-10-29 18:40:02.382
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.Arrays;
import java.util.Iterator;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    private long gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	      int answer = 0;
	      Stack<Integer> stack = new Stack<>();
	      int minA =arrayA[0];
	      
	      for (int i = 1; i < arrayA.length; i++) {
	    	  minA = Math.min(minA, arrayA[i]);
	      }
	      for (int i = 1; i <= minA; i++) {
	    	  boolean divisor = true;
	    	  for (int j = 0; j < arrayA.length; j++) {
				
	    		  if(arrayA[j] % i != 0)  {
	    			  divisor = false;
	    			  j = arrayA.length;
	    		  }
	    	  }
	    	  if(divisor == true) stack.push(i);
	      }
	      System.out.println(stack);
	      
	      for (int i = 1; i <= minA; i++) {
	    	  boolean divisor = true;
	    	  for (int j = 0; j < arrayA.length; j++) {
				
	    		  if(arrayA[j] % i != 0)  {
	    			  divisor = false;
	    			  j = arrayA.length;
	    		  }
	    	  }
	    	  if(divisor == true) stack.push(i);
	      }
	      

	      while (!stack.isEmpty()) {
	    	  for
	    	  
	    	  
	    	  if(arrayB[0] % stack.peek() != 0 && arrayB[1] % stack.peek() != 0) {
	    		  answer = stack.peek();
	    		  break;
	    	  }
	    	  stack.pop();
	      }
	      
//	      System.out.println(answer);
	      return answer;
	  }
	  
	  
    
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-10-29 18:40:02.384
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-10-29 18:40:02.385
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SESSION 2024-10-31 21:46:21.432 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2024-10-31 21:46:29.106
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2024-10-31 21:46:52.026
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-31 21:46:52.026
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-10-31 21:46:52.026
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-10-31 21:46:56.078
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-04 16:16:15.975 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-11-04 16:16:49.376
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-04 16:16:49.376
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-04 16:16:49.376
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-04 16:16:54.424
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-05 14:29:23.569 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2024-11-05 14:31:56.817
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2024-11-05 14:32:18.634
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-05 14:32:18.634
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-05 14:32:18.634
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-05 14:32:22.474
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-06 23:19:37.314 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-11-06 23:20:07.854
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-06 23:20:07.854
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-06 23:20:07.854
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-06 23:20:11.527
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-07 16:59:45.061 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-11-07 17:00:25.552
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-07 17:00:25.552
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-07 17:00:25.552
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-07 17:00:32.443
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-08 13:35:21.862 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-11-08 14:39:20.236
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-08 14:39:20.237
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-08 14:39:20.237
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-08 14:39:24.910
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-11 15:32:59.771 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-11-11 15:33:32.868
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-11 15:33:32.869
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-11 15:33:32.869
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-11 15:33:37.544
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-12 17:34:01.176 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-11-12 17:34:35.261
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-12 17:34:35.261
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-12 17:34:35.261
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-12 17:34:38.896
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-18 15:29:03.357 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-11-18 15:29:40.526
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-18 15:29:40.526
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-18 15:29:40.526
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-18 15:29:45.067
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 2 2024-11-18 16:23:32.512
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.dom.Type.accept(org.eclipse.jdt.core.dom.ASTVisitor)" because "type" is null
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.getQualifiedTypeName(ASTNodes.java:1171)
	at org.eclipse.jdt.internal.ui.text.correction.proposals.CreateObjectReferenceProposal.findReference(CreateObjectReferenceProposal.java:150)
	at org.eclipse.jdt.internal.ui.text.correction.proposals.CreateObjectReferenceProposal.hasProposal(CreateObjectReferenceProposal.java:84)
	at org.eclipse.jdt.internal.ui.text.correction.LocalCorrectionsSubProcessor.addObjectReferenceProposal(LocalCorrectionsSubProcessor.java:867)
	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.process(QuickFixProcessor.java:493)
	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.getCorrections(QuickFixProcessor.java:360)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:381)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:341)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:336)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:465)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:115)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-11-21 13:48:14.058 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-11-21 13:49:10.225
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-21 13:49:10.225
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-21 13:49:10.226
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-21 13:49:17.367
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-22 14:22:56.353 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-11-22 15:24:18.692
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-22 15:24:18.692
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-22 15:24:18.692
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-22 15:24:24.261
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-25 15:00:56.792 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-11-25 15:01:27.151
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-25 15:01:27.151
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-25 15:01:27.151
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-25 15:01:31.493
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-26 16:14:16.895 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-11-26 16:14:51.607
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-26 16:14:51.607
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-26 16:14:51.607
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-26 16:14:56.492
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-26 18:00:14.931 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-11-26 18:00:30.182
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-26 18:00:30.182
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-26 18:00:30.182
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-26 18:00:34.016
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-28 15:23:51.395 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-11-28 15:31:06.970
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-28 15:31:06.970
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-28 15:31:06.970
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-28 15:31:12.731
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-11-28 15:31:01.643 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2024-11-28 16:19:32.524
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2024-11-28 16:19:35.950
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-28 16:19:35.950
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-11-28 16:19:35.950
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-11-28 16:19:40.260
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-12-02 15:44:52.478 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-12-02 15:45:31.904
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-02 15:45:31.905
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-02 15:45:31.905
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-12-02 15:45:37.572
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-12-03 14:56:25.224 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-12-03 14:58:20.976
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-03 14:58:20.976
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-03 14:58:20.976
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-12-03 14:58:25.783
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-12-05 15:32:39.236 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-12-05 15:33:17.907
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-05 15:33:17.907
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-05 15:33:17.907
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-12-05 15:33:22.189
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-12-06 16:11:32.663 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2024-12-06 16:11:41.853
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2024-12-06 16:12:11.977
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-06 16:12:11.977
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-06 16:12:11.977
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-12-06 16:12:17.149
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-12-09 15:32:31.294 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-12-09 15:35:52.928
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-09 15:35:52.928
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-09 15:35:52.928
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-12-09 15:35:58.141
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-12-10 15:23:13.728 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-12-10 15:23:40.565
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-10 15:23:40.565
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-10 15:23:40.565
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-12-10 15:23:45.212
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:28:27.104
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        
	        while (n <= 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-12-10 15:28:27.108
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-12-10 15:28:27.109
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:28:27.205
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        
	        while (n <= 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-12-10 15:28:27.207
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-12-10 15:28:27.208
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:28:29.900
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-12-10 15:28:29.902
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-12-10 15:28:29.902
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:28:30.598
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-12-10 15:28:30.599
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-12-10 15:28:30.599
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:28:45.846
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-12-10 15:28:45.848
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-12-10 15:28:45.849
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:28:49.817
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-12-10 15:28:49.819
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-12-10 15:28:49.819
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:28:49.986
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-12-10 15:28:49.987
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-12-10 15:28:49.988
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:28:54.518
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        int n
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-12-10 15:28:54.519
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-12-10 15:28:54.520
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:28:55.995
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        int num =
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-12-10 15:28:55.995
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-12-10 15:28:55.998
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:28:56.080
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        int num =
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-12-10 15:28:56.081
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-12-10 15:28:56.081
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:28:59.858
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        int num = 
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-12-10 15:28:59.859
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-12-10 15:28:59.860
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:28:59.969
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        int num = 
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-12-10 15:28:59.970
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-12-10 15:28:59.970
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:29:53.528
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-12-10 15:29:53.530
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-12-10 15:29:53.531
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:29:54.035
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-12-10 15:29:54.035
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-12-10 15:29:54.036
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:30:03.330
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-12-10 15:30:03.330
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-12-10 15:30:03.331
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-12-10 15:30:05.001
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package programmers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Programmers {
	
    public String solution1(int n, int k, String[] cmd) {
        String answer = "";
        Scanner sc = new Scanner(System.in);
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = "";
        char charInput;
        int count = 0;
        String[] arr= new String[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < arr.length; i++) {
			arr[i]="O";
		}
        
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
      
        do {
        	System.out.print("입력 : ");
        	input = sc.nextLine();
//        	input = br.readLine();
        	charInput = input.charAt(0);
//        	System.out.println(charInput);
        	if(charInput =='U' || charInput =='D' ) {
        		count = Integer.parseInt(input.substring(2));
        	}
        	
        	
        	boolean isFirst = true;
        	boolean isLast = true;
        	
        	for (int i = k-1; i > 0; i--) {
        		if(arr[i-1] == "O") {
        			isFirst = false;
        		}
        	}
        	
        	for (int i = k; i < arr.length; i++) {
        		if(arr[i] == "O") {
        			isLast = false;
        		}
        	}
        	
        	
//        	U
        	if(charInput == 'U') {
        		while(count != 0) {
        			if(arr[k-2]=="O") {
        				k--;
        				count--;
        			}else if(arr[k-2]=="X" && !isFirst) { 
        				k--;
        			}else break;
        		}
        		
        		if(k <= 1) {
        			for (int i = 0; i < arr.length; i++) {
        				if(arr[i] == "X") k++;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
        		
//        	D	
        	}else if(charInput == 'D') {
        		
        		while(count != 0) {
        			if(arr[k]=="X" && k+1 < n) { 
        				k++;
        			}else if(arr[k]=="O") {
        				k++;
        				count--;
        			}
        			else break;
        		}
        		
        		if(k >= n) {
        			for (int i = arr.length; i > 0; i--) {
        				if(arr[i-1] == "X") k--;
        				else break;
					}
        		}
        		System.out.print(Arrays.toString(arr));
        		System.out.println(k);
//        	C
        	}else if(charInput == 'C') {
        		stack.push(k);
        		
        		arr[k-1] = "X";
        		
        		if (isLast) {
        			for (int i = k; i > 0; i--) {
						if(arr[i-1] == "O") {
							k = i ;
							i = 0;
						}
					}
					
				}else {
					for (int i = k; i < arr.length; i++) {
						if(arr[i] == "O") {
							k = i + 1;
							i = arr.length;
						}
					}
				}
        		
        		
        		
//        		if(isFirst) {
//        			for (int i = k; i < arr.length; i++) {
//        				if(arr[i] == "O") {
//        					k = i + 1;
//        					i = arr.length;
//        				}
//        			}
//        		}else {
//        			for (int i = k; i > 0; i--) {
//        				if(arr[i-2] == "O") {
//        					i = 0;
//        				}
//        				k--;
//        			}
//        		}
        		         
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
//        	Z	
           	}else if(charInput == 'Z') {
           		arr[stack.pop()-1] = "O";
           		   
        		
        		System.out.print(Arrays.toString(arr));
        		System.out.print(k);
        		System.out.println(stack);
        		
        		
        	}else if(charInput == 'a') {
        		
        		for (String i : arr) {
        			answer += i;
        		}
        		System.out.println(answer);
        	}
        	
        	
        }while(charInput != 'a');
        
        return answer;
    }
    
    
    
    public String solution2(int n, int k, String[] cmd) {
    	int K = k + 1;
    	String answer = "";
    	char charInput;
    	int count = 0;
    	String[] arr= new String[n];
    	Stack<Integer> stack = new Stack<>();
    	
    	for (int i = 0; i < arr.length; i++) {
    		arr[i]="O";
    	}
    	
//        if(arr[0]=="O") System.out.println("true");
//    	else System.out.println("false");
    	
    	for (int x = 0; x < cmd.length; x++) {
    		
    		charInput = cmd[x].charAt(0);
    		if(charInput =='U' || charInput =='D' ) {
    			count = Integer.parseInt(cmd[x].substring(2));
    		}
    		
    		
    		boolean isFirst = true;
    		boolean isLast = true;
    		
    		for (int i = K-1; i > 0; i--) {
    			if(arr[i-1] == "O") {
    				isFirst = false;
    			}
    		}
    		
    		for (int i = K; i < arr.length; i++) {
    			if(arr[i] == "O") {
    				isLast = false;
    			}
    		}
    		
    		
//        	U
    		if(charInput == 'U') {
    			while(count != 0) {
    				if(arr[K-2]=="O") {
    					K--;
    					count--;
    				}else if(arr[K-2]=="X" && !isFirst) { 
    					K = K-1;
//    					K--;
    				}else break;
    			}
    			
    			if(K <= 1) {
    				for (int i = 0; i < arr.length; i++) {
    					if(arr[i] == "X") K++;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
    			
//        	D	
    		}else if(charInput == 'D') {
    			
    			while(count != 0) {
    				if(arr[K]=="X" && K+1 < n) { 
    					K++;
    				}else if(arr[K]=="O") {
    					K++;
    					count--;
    				}
    				else break;
    			}
    			
    			if(K >= n) {
    				for (int i = arr.length; i > 0; i--) {
    					if(arr[i-1] == "X") K--;
    					else break;
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.println(k);
//        	C
    		}else if(charInput == 'C') {
    			stack.push(K);
    			
    			arr[K-1] = "X";
    			
    			if (isLast) {
    				for (int i = K; i > 0; i--) {
    					if(arr[i-1] == "O") {
    						K = i ;
    						i = 0;
    					}
    				}
    				
    			}else {
    				for (int i = K; i < arr.length; i++) {
    					if(arr[i] == "O") {
    						K = i + 1;
    						i = arr.length;
    					}
    				}
    			}
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    			
    			
//        	Z	
    		}else if(charInput == 'Z') {
    			arr[stack.pop()-1] = "O";
    			
    			
//    			System.out.print(Arrays.toString(arr));
//    			System.out.print(k);
//    			System.out.println(stack);
    		}
    		
		}
    	
    	
    	for (String i : arr) {
    		answer += i;
    	}
    	System.out.println(answer);
    	
    	return answer;
    }
    
    
//	숫자 블록
	public int[] solution3(long begin, long end) {
        int[] all = new int[100];
        for (int i = 1; i < all.length/2 + 1; i++) {
        	for (int j = 2; j < all.length; j++) {
        		if((i * j) - 1 < all.length) {
        			all[(i * j) - 1] = i;
        		}
			}
		}
        
        int index = 0;
        int[] answer = new int[(int)end-(int)begin+1];
        for (int i = (int) (begin-1); i < end; i++) {
        	answer[index] = all[i];
        	index++;
		}
        System.out.println(Arrays.toString(all));
        System.out.println(Arrays.toString(answer));
        return answer;
	}
	
	
//	조이스틱(x)
    public int solution4(String name) {
        int answer = 0;
        char[] nameArr = new char[name.length()];
        //A=65
        for (int i = 0; i < nameArr.length; i++) {
			nameArr[i] = name.charAt(i);
			System.out.println((int)nameArr[i] - (int)'A');
			
			if((int)nameArr[i] <79) answer = answer +  (int)nameArr[i] - (int)'A';
			else answer = answer +  (int)'Z' + 1 - (int)nameArr[i];
		}
        
        
        answer = answer + name.length()-1;
        System.out.println(answer);
        return answer;
    }
	
    
//	입국심사 
    public long solution5(int n, int[] times) {
        long answer = 0;
        for (long i = 1; i < times[0] * n; i++) {
			if(i/times[0] + i/times[1] >= n) {
				answer = i;
//				System.out.println(answer);
				break;
			} 
		}
        return answer;
    }
	
    
//  멀쩡한 사각형  
    public long solution6(int w, int h) {
        long answer = 1;
        long divisor = gcd(w, h);
        
//        long divisor = 0;
//        for (int i = 1; i <= w; i++) {
//			if(h % i == 0 && w % i == 0) divisor = i;
//		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    
    public long solution7(int w, int h) {
        long answer = 1;
        long divisor = 0;
        for (int i = 1; i <= w; i++) {
			if(h % i == 0 && w % i == 0) divisor = i;
		}
        
        answer = ((long)w * (long)h) - ((long)w + (long)h - divisor);
        return answer;
    }
    
    
    //점 찍기(x)
    public long solution8(int k, int d) {
        long answer = 0;
        for (int i = 0; i <= d; i+=k) {
			for (int j = 0; j <= d; j+=k) {
				if(i*i + j*j <= d*d) {
					answer = answer + 1;
//					System.out.print(i);
//					System.out.println(j);
				}
			}
		}
        System.out.println(answer);
        return answer;
    }    
   
    
//  풍선 터트리기  
    public int solution9(int[] a) {
        int answer = 2;
        int[] min =new int[3];
        
        for (int i = 1; i < a.length-1; i++) {
        	min[0] = Arrays.stream(Arrays.copyOfRange(a, 0, i)).min().getAsInt();
        	min[1] = a[i];
        	min[2] = Arrays.stream(Arrays.copyOfRange(a, i+1, a.length)).min().getAsInt();
        	if(min[1] != Arrays.stream(Arrays.copyOfRange(min, 0, min.length)).max().getAsInt()) {
        		answer++;
        	}
		}
        System.out.println(answer);
        return answer;
    }
    
    
//  자물쇠와 열쇠(X)
	  public boolean solution10(int[][] key, int[][] lock) {
	  	boolean answer = true;
	  	int[][] key2 = new int[key.length][key[0].length];
	  	int[][] key3 = new int[key.length][key[0].length];
	  	int[][] key4 = new int[key.length][key[0].length];
	  	
//  	key를 90도 횐전시켜 key2
	  	for (int i = 0; i < key.length; i++) {
	  		for (int j = 0; j < key[i].length; j++) {
	  			key2[i][j]=key[2-j][i];
					System.out.print(key2[i][j]);
				}
				System.out.println();
			}
	  	
	  	System.out.println();
//  	key2를 90도 횐전시켜 key3
	  	for (int i = 0; i < key2.length; i++) {
	  		for (int j = 0; j < key2[i].length; j++) {
	  			key3[i][j]=key2[2-j][i];
	  			System.out.print(key3[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	System.out.println();
//  	key3를 90도 횐전시켜 key4
	  	for (int i = 0; i < key3.length; i++) {
	  		for (int j = 0; j < key3[i].length; j++) {
	  			key4[i][j]=key3[2-j][i];
	  			System.out.print(key4[i][j]);
	  		}
	  		System.out.println();
	  	}
	  	
	  	for (int i = 0; i < lock.length; i++) {
				for (int j = 0; j < lock[i].length; j++) {
					if(true){
					}else answer = false;
					
				}
			}
	  	
	  	
	  	System.out.println(answer);
	      return answer;
	  }
	  
	  
	  
//		가장 큰 정사각형 찾기(X)
	  public int solution11(int[][] board) {
	        int answer = 1234;
	        int w = 0;
	        boolean tf = true;
	        for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board[0].length; j++) {
					while(tf) {
						
					}
					
					
					
				}
			}
	        
	        return answer;
	    }
	  
//	  숫자 카드 나누기
	  public int solution12(int[] arrayA, int[] arrayB) {
	        int answer = 0;
	        // arrayA와 arrayB 각각의 최대공약수 구하기
	        int gcdA = findGCD(arrayA);
	        int gcdB = findGCD(arrayB);

	        boolean validGcdA = true;
	        for (int i = 0; i < arrayB.length; i++) {
	            if (arrayB[i] % gcdA == 0) {
	                validGcdA = false;
	                break;
	            }
	        }
	        if (validGcdA) {
	            answer = Math.max(answer, gcdA);
	        }

	        boolean validGcdB = true;
	        for (int i = 0; i < arrayA.length; i++) {
	            if (arrayA[i] % gcdB == 0) {
	                validGcdB = false;
	                break;
	            }
	        }
	        if (validGcdB) {
	            answer = Math.max(answer, gcdB);
	        }
	        System.out.println(answer);
	        return answer;		  
	  }
	    // 배열의 최대공약수 구하기
	    public static int findGCD(int[] array) {
	        int result = array[0];
	        for (int i = 1; i < array.length; i++) {
	            result = gcd(result, array[i]);
	        }
	        return result;
	    }
	  
	    
//	    가장 큰 수
	    public String solution13(int[] numbers) {
	        String answer = "";
	        String[] strNumbers = new String[numbers.length];
	        for (int i = 0; i < numbers.length; i++) {
	        	strNumbers[i] = String.valueOf(numbers[i]);
			}
	        
	        Arrays.sort(strNumbers, new Comparator<String>() {
	            @Override
	            public int compare(String num1, String num2) {
	                // 두 문자열을 연결한 후 비교
	                return (num2 + num1).compareTo(num1 + num2);
	            }
	        });
	        
	        for (int i = 0; i < strNumbers.length; i++) {
	        	answer += strNumbers[i];
			}
	        
	        if (answer.charAt(0) == '0') {
	            return "0";
	        }
	        return answer;
	    }
	  
	    
	    
//	    햄버거 만들기
	    public int solution14(int[] ingredient) {
	        int answer = 0;
	        Stack<Integer> stack = new Stack<>();

	        for (int i = 0; i < ingredient.length; i++) {
	            stack.push(ingredient[i]);  

	            if (stack.size() >= 4 && stack.get(stack.size() - 4) == 1 
	            		&& stack.get(stack.size() - 3) == 2 && stack.get(stack.size() - 2) == 3 
	            		&& stack.get(stack.size() - 1) == 1) {
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                stack.pop();
	                answer++;  
	            }
	        }

	        return answer;
	    }
    
	    
	    
//	    2개 이하로 다른 비트
	    public long[] solution15(long[] numbers) {
	        long[] answer = new long[numbers.length];
//	        String[] binaryNum = new String[numbers.length];
//	        for (int i = 0; i < binaryNum.length; i++) {
//	        	binaryNum[i] = Long.toBinaryString(numbers[i]);
//			}
	        
	        for (int i = 0; i < numbers.length; i++) {
	            long number = numbers[i];
	            
	            long next = number + 1; 
	            while (true) {
	                int bitDiff = Long.bitCount(number ^ next);
	                if (bitDiff == 1 || bitDiff == 2) {
	                    answer[i] = next;
	                    break;
	                }
	                next++;
	            }
	        }
	        
	        System.out.println(Arrays.toString(numbers));
	        System.out.println(Arrays.toString(answer));
	        
	        return answer;
	    }
	    
	    
//		두 큐 합 같게 만들기(x)
	    public int solution16(int[] queue1, int[] queue2) {
	        int answer = -2;
	        int[] queue3 = new int[queue1.length + queue2.length];
	        
	        int sum = 0;
	        int max = 0;
	        
	        for (int i = 0; i < queue1.length; i++) {
				if(queue1[i] > max) max = queue1[i];
				sum = sum + queue1[i];
				
				queue3[i] = queue1[i];
			}
	        for (int i = 0; i < queue2.length; i++) {
	        	if(queue1[i] > max) max = queue1[i];
	        	sum = sum + queue2[i];
	        	
	        	queue3[i + queue1.length] = queue2[i];
	        }
	        if(sum/2 < max) return -1;
	        
	        
	        
	        
	        System.out.println(sum);
	        System.out.println(Arrays.toString(queue3));
	        
	        return answer;
	    }
	    private static boolean canSumToTarget(int[] arr, int target, int startIndex) {
	    	
	        for (int i = startIndex; i < arr.length; i++) {
	            if (canSumToTarget(arr, target - arr[i], i + 1)) {
	            	
	                return true;
	            }
	        }

	        return false;
	    }
	    
	    
	    
//	    소수 찾기
	    public int solution17(String numbers) {
	        int answer = 0;
	        List<Integer> numList = new ArrayList<>();
	        
	        findPermutations("", numbers, numList);
	        
	        numList = new ArrayList<>(new HashSet<>(numList));  // 중복 제거
	        
	        for (int num : numList) {
	            if (isPrime(num)) {
	            	answer++;
	            }
	        }
	        System.out.println(answer);
	        return answer;
	    }   
	    public boolean isPrime(int num) {
	        if (num <= 1) return false;
	        for (int i = 2; i <= Math.sqrt(num); i++) {
	            if (num % i == 0) {
	                return false; 
	            }
	        }
	        return true; 
	    }
//	    재귀적으로 순열을 구하는 함수
	    public void findPermutations(String prefix, String numbers, List<Integer> numList) {
	        if (prefix.length() > 0) {
	            numList.add(Integer.parseInt(prefix)); // 
	        }
	        
	        for (int i = 0; i < numbers.length(); i++) {
	            findPermutations(prefix + numbers.charAt(i), numbers.substring(0, i) + numbers.substring(i + 1), numList);
	        }
	    }
	    


//		다리를 지나는 트럭
	    public int solution18(int bridge_length, int weight, int[] truck_weights) {
	        int answer = bridge_length;
	        int currentWeight = 0;
	        int index = 0;
	        Queue<Integer> bridge = new ArrayDeque<>();
	        
	        while(index < truck_weights.length) {
	        	answer++;
	            if (bridge.size() == bridge_length) {
	                currentWeight -= bridge.poll();  
	            }
	        	
	            if (index < truck_weights.length && currentWeight + truck_weights[index] <= weight) {
	                bridge.offer(truck_weights[index]);  
	                currentWeight += truck_weights[index];  
	                index++;  
	            } else {
	                bridge.offer(0);  
	            }
	        }
	        
	        
	        System.out.println(answer);
	        return answer;
	    }	 
	    
	    
//	    평행

	    public int solution19(int[][] dots) {
	        int answer = 0;
	        List<double[]> list =new ArrayList<>();
	        double[][] line1 = new double[2][2];
	        double[][] line2 = new double[2][2];
	        double[][] doubleDots = new double[4][2];
	        for (int i = 0; i < doubleDots.length; i++) {
				for (int j = 0; j < doubleDots[i].length; j++) {
					doubleDots[i][j] = (double)dots[i][j];
				}
			}
	        
	        for (int i = 0; i < dots.length; i++) {
				list.add(doubleDots[i]);
			}
	        for (int i =  1; i < list.size(); i++) {
                line1[0] = list.get(0);
                line1[1] = list.get(i);
                
                int count = 0;
                for (int j = 1; j < list.size(); j++) {
                    if (j != 0 && j != i) {
                    
                    	line2[count] = list.get(j);
                    	count++;
                    }
                }
                
                if((line1[0][1] - line1[1][1]) / (line1[0][0] - line1[1][0]) 
                		== (line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0])) {
                	answer = 1;
                	break;
                }
	        }
	        return answer;
	    }
	    
	    
	    
	    
//	    연속된 부분 수열의 합
	    public int[] solution20(int[] sequence, int k) {
	        int[] answer = new int[2];
	        int len =sequence.length;
	        for (int i = 0; i < sequence.length; i++) {
	        	int sum = 0;
	        	for (int j = i; j < sequence.length; j++) {
	        		sum = sum + sequence[j];
					
	                if (sum == k) {
	                	
	                    if (j - i < len) {
	                        len = j - i;
	                        answer[0] = i;
	                        answer[1] = j;
	                    }
	                    break;  
	                }
	        		if(sum > k) break;
				}
				
			}
	        System.out.println(answer[0]);
	        System.out.println(answer[1]);
	        
	        
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    삼각 달팽이
	    public int[] solution21(int n) {
	        int[] answer = {};
	        int[][] arr = new int[n][n];
	        int num = 1;
	        int end = 0;
	        for (int i = 1; i <= n; i++) {
				end += i;
			}
	        answer = new int[end];
	        
	        int[] dx = {1, 0, -1};  
	        int[] dy = {0, 1, -1}; 
	        int x = 0; 
	        int y = 0;
	        int direction = 0;
	        
	        while(num <= end) {
	        	arr[x][y] = num;
	        	
	        	int nextX = x + dx[direction];
	        	int nextY = y + dy[direction];
	        	
	        	if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || arr[nextX][nextY] != 0) {
	                direction = (direction + 1) % 3;  
	                nextX = x + dx[direction];
	                nextY = y + dy[direction];
	            }
	        	
	        	x = nextX;
	            y = nextY;
	        	num++;
	        }
	        
	        for (int i = 0; i < arr.length; i++) {
				for (int j = 0; j < arr[0].length; j++) {
					System.out.print(arr[i][j]+ "\t");
				}
				System.out.println();
			}
	        num = 0;
	        for (int i = 0; i < arr.length; i++) {
	        	for (int j = 0; j < arr[0].length; j++) {
	        		if(arr[i][j] != 0) {
	        			answer[num] = arr[i][j];
	        			num++;
	        		}
	        	}
	        }
	        System.out.println(Arrays.toString(answer));
	        return answer;
	    }
	    
	    
//	    2차원배열 출력
	    public void printArray2(int[][] arr) {
	    	for (int i = 0; i < arr.length; i++) {
	    		for (int j = 0; j < arr[0].length; j++) {
	    			System.out.print(arr[i][j] + " ");
	    		}
	    		System.out.println();
	    	}
	    }
	    
	    
//	    크레인 인형뽑기 게임
	    public int solution22(int[][] board, int[] moves) {
	        int answer = 0;
	        printArray2(board);
	        Stack<Integer> stack = new Stack<>();
	        
	        for (int i = 0; i < moves.length; i++) {
				for (int j = 0; j < board.length; j++) {
					if(board[j][moves[i] - 1] != 0) {
						if(!stack.isEmpty()) {
							if(board[j][moves[i] - 1] == stack.peek()) {
								board[j][moves[i] - 1] = 0;
								stack.pop();
								answer += 2;
								break;
							}
//							else {
//								stack.push(board[j][moves[i] - 1]);
//								board[j][moves[i] - 1] = 0;
//								break;
//							}
						}
						stack.push(board[j][moves[i] - 1]);
						board[j][moves[i] - 1] = 0;
						break;
					}
				}
			}
	        System.out.println(stack);
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
	    
//		큰 수 만들기
	    public String solution23(String number, int k) {
	        String answer = "";
	        int[] arr = new int[number.length()];
	        Queue<Integer> que = new LinkedList<>();
	        int start = 0;
	        
	        for (int i = 0; i < arr.length; i++) {
				arr[i] = Integer.parseInt(number.substring(i, i+1));
				que.offer(Integer.parseInt(number.substring(i, i+1)));
			}
	        
	        while(k > 0) {
	        	int max = 0;
	        	int count = 0;
	        	for (int i = start; i <= k+start; i++) {
					if(max < arr[i]) max = arr[i];
				}
	        	for (int i = 0; i <= k; i++) {
	        		if(max != que.peek()) {
	        			start++;
	        			count++;
	        			que.poll();
	        			
	        		}else{
	        			answer += que.poll();
	        			start++;
	        			k = k-count;
	        			break;
	        		}
	        	}
	        }
	        
	       while(!que.isEmpty()) {
	    	   answer += que.poll();
	       }
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    시소 짝꿍
	    public long solution24(int[] weights) {
	        long answer = 0;
	        int[] sortWeights = Arrays.copyOf(weights, weights.length);
	        Arrays.sort(sortWeights);
	        
	        for (int i = 0; i < sortWeights.length-1; i++) {
				for (int j = i+1; j < sortWeights.length; j++) {
					if(sortWeights[i] == sortWeights[j] || sortWeights[i]*2 == sortWeights[j] || sortWeights[i]*3 == sortWeights[j]*2 || sortWeights[i]*4 == sortWeights[j]*3) {
						answer++;
					}
				}
			}
	        return answer;
	    }
//	    시소 짝꿍
	    public long solution25(int[] weights) {
	        long answer = 0;
	        HashMap<Integer, Integer> weightMap = new HashMap<>();
	        for (int weight : weights) {
	            weightMap.put(weight, weightMap.getOrDefault(weight, 0) + 1);
	        }
	        for (int weight : weightMap.keySet()) {
	            int count = weightMap.get(weight); 
	            answer += (long) count * (count - 1) / 2; 
	            if (weightMap.containsKey(weight * 2)) {
	                answer += (long) count * weightMap.get(weight * 2);
	            }
	            if (weightMap.containsKey(weight * 3 / 2)) {
	                answer += (long) count * weightMap.get(weight * 3 / 2);
	            }
	            if (weightMap.containsKey(weight * 4 / 3)) {
	                answer += (long) count * weightMap.get(weight * 4 / 3);
	            }
	        }

	        System.out.println(answer);
	        return answer;
	    }
	    
	    
	    
//	    마법의 엘리베이터(x)
	    public int solution26(int storey) {
	        int answer = 0;
	        String storeyStr = String.valueOf(storey);
	        int[] storeyArr = new int[storeyStr.length()];
	        for (int i = 0; i < storeyArr.length; i++) {
				storeyArr[storeyArr.length-i-1] = Integer.parseInt(storeyStr.substring(i, i+1));
			}
	        
	        
	    	for (int i = 0; i < storeyArr.length; i++) {
	    		while(storeyArr[i]!=0) {
	    			if (i == storeyArr.length - 1) {
	    				answer += storeyArr[i];
    					storeyArr[i] = 0;
					}
	    			
	    			else {
	    				if(storeyArr[i] >= 6) {
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}else if(storeyArr[i] >= 5 && storeyArr[i+1] >= 5 ){
	    					answer += 10 - storeyArr[i];
	    					storeyArr[i] = 0;
	    					storeyArr[i+1]++;
	    				}
	    				else {
	    					answer += storeyArr[i];
	    					storeyArr[i] = 0;
	    				}
	    			}
	    		}
	    		System.out.println(Arrays.toString(storeyArr));
	    		System.out.println(answer);
			}
	        return answer;
	    }
	    
	    
	    
//	    성격 유형 검사하기
	    public String solution28(String[] survey, int[] choices) {
	        String answer = "";
	        HashMap<String, Integer> map = new HashMap<>();
	        map.put("R", 0);
	        map.put("T", 0);
	        map.put("C", 0);
	        map.put("F", 0);
	        map.put("J", 0);
	        map.put("M", 0);
	        map.put("A", 0);
	        map.put("N", 0);
	        System.out.println(map);
	        for (int i = 0; i < survey.length; i++) {
	        	switch (survey[i]) {
	            case "RT":
	            	if (choices[i] <= 3) {
	            		map.put("R", map.get("R") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("T", map.get("T") + (choices[i] - 4));
					}
	            	break;
	            case "TR":
	            	if (choices[i] <= 3) {
	            		map.put("T", map.get("T") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("R", map.get("R") + (choices[i] - 4));
	            	}
	                break;
	                
	            case "CF":
	            	if (choices[i] <= 3) {
	            		map.put("C", map.get("C") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("F", map.get("F") + (choices[i] - 4));
					}
	            	break;
	            case "FC":
	            	if (choices[i] <= 3) {
	            		map.put("F", map.get("F") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("C", map.get("C") + (choices[i] - 4));
	            	}
	                break;
	            case "JM":
	            	if (choices[i] <= 3) {
	            		map.put("J", map.get("J") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("M", map.get("M") + (choices[i] - 4));
					}
	            	break;
	            case "MJ":
	            	if (choices[i] <= 3) {
	            		map.put("M", map.get("M") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("J", map.get("J") + (choices[i] - 4));
	            	}
	            	break;
	            case "AN":
	            	if (choices[i] <= 3) {
	            		map.put("A", map.get("A") + (4 - choices[i]));
					}else if (choices[i] >= 5) {
						map.put("N", map.get("N") + (choices[i] - 4));
					}
	            	break;
	            case "NA":
	            	if (choices[i] <= 3) {
	            		map.put("N", map.get("N") + (4 - choices[i]));
	            	}else if (choices[i] >= 5) {
	            		map.put("A", map.get("A") + (choices[i] - 4));
	            	}
	            	break;
	        	}
			}
	        
	        if (map.get("R") < map.get("T"))	answer += "T";
	        else								answer += "R";
	        	
	        if (map.get("C") < map.get("F"))	answer += "F";
	        else								answer += "C";
	        
	        if (map.get("J") < map.get("M"))	answer += "M";
	        else								answer += "J";
	        
	        if (map.get("A") < map.get("N"))	answer += "N";
	        else								answer += "A";
	        
	        	
//	        System.out.println(map);
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    호텔 대실
	    public int solution29(String[][] book_time) {
	        int answer = 1;
	        Arrays.sort(book_time, Comparator.comparing(a -> a[0]));
	        int[][] book_time_int = new int[book_time.length][book_time[0].length];
	        
	        for (int i = 0; i < book_time_int.length; i++) {
	        	for (int j = 0; j < book_time_int[i].length; j++) {
	        		book_time_int[i][j] = changeTime(book_time[i][j]);
	        		System.out.printf(book_time_int[i][j]+" ");
				}
	        	System.out.println();
			}
	        
	        for (int i = 1; i < book_time_int.length; i++) {
	        	int count = 0;
	        	for (int j = 0; j < i; j++) {
					if (book_time_int[i][0] < book_time_int[j][1] + 10) {
						count++;
						if(count == answer) {
							answer++;
							System.out.println(answer);
							break;
						}
					}
				}
			}
	        
	        
	        
//	        System.out.println(answer);
	        return answer;
	    }
	    
	    public int changeTime(String time) {
	    	int h =Integer.parseInt(time.substring(0, 2));
	    	int m =Integer.parseInt(time.substring(3, 5));
	    	int result = h*60 +m;
	    	
			return result;
		}
	    
	    
	    
//	    신규 아이디 추천
	    public String solution30(String new_id) {
	        String answer = "";
	        StringBuilder builder = new StringBuilder(new_id);
//	        1
	        for (int i = 0; i < builder.length(); i++) {
				if('A' <= builder.charAt(i) && builder.charAt(i) <= 'Z') {
					builder.setCharAt(i, (char)(builder.charAt(i)+32));
				}
			}
//	        2
	        for (int i = 0; i < builder.length(); i++) {
	            if ((builder.charAt(i) < 'a' || builder.charAt(i) > 'z')  
	                    && builder.charAt(i) != '-'
	                    && builder.charAt(i) != '_'
	                    && builder.charAt(i) != '.'
	                    && (builder.charAt(i) < '0' || builder.charAt(i) > '9')) {  
	                    builder.deleteCharAt(i);
	                    i--; 
	                }
	        }
//	        3
	        for (int i = 1; i < builder.length(); i++) {
	        	if (builder.charAt(i)=='.' && builder.charAt(i-1)=='.') {
	        		builder.deleteCharAt(i);
                    i--; 
				}
	        }
	        
//	        4
	        if (builder.charAt(0)=='.') {
	        	builder.deleteCharAt(0);
			}
	        if (builder.length() != 0) {
	        	if (builder.charAt(builder.length()-1)=='.') {
	        		builder.deleteCharAt(builder.length()-1);
	        	}
			}
//	        5
	        if (builder.length()==0) {
	        	builder.append("a");
			}
//	        6
	        if (builder.length() > 15) {
	        	builder.delete(15, builder.length());
	        }
	        
//	        7
	        while (builder.length() < 3) {
	        	builder.append(builder.charAt(builder.length()-1));
	        }
	        
	        answer = builder.toString();
	        System.out.println(answer);
	        return answer;
	    }
	    
	    
//	    124 나라의 숫자
	    public String solution(int n) {
	        String answer = "";
	        List<Integer> list = new ArrayList<>();
	        while (n > 3) {
				n/3
			}
	        
	        return answer;
	    }
}   
    
	



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-12-10 15:30:05.003
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-12-10 15:30:05.003
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-12-16 15:38:39.031 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-12-16 15:39:27.186
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-16 15:39:27.186
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-16 15:39:27.186
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-12-16 15:39:37.512
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-12-17 16:16:04.518 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2024-12-17 16:16:36.770
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-17 16:16:36.770
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-12-17 16:16:36.770
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-12-17 16:16:41.986
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kmcsl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
